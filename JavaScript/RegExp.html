<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>正则表达式对象</title>
	</head>
	<body>
	</body>
</html>
<script type="text/javascript">
	/*创建正则表达式的方式有两种：1.以字面量的形式创建 eg:var experssion = /pattern/ flags  (字面量形式只需转义一次就行)
	 						    2.以构造函数的形式创建 eg:var experssion = new RegExp("pattern","flags")(构造函数参数是字符串，所有元字符都需要双重转义)
	*/
	/*
		n+	匹配任何包含一个或多个n的字符串。
		n*	匹配任何包含零个或多个n的字符串。
		n?	匹配任何包含零个或一个n的字符串。
		n{X}	匹配包含刚好有 X 个n的序列的字符串。
		n{X,Y}	匹配包含 至少 X个但不超过 Y个 n 的序列的字符串。
		n{X,}	匹配包含至少有 X 个 n 的序列的字符串。
		n$	匹配任何结尾为 n 的字符串。
		^n	匹配任何开头为 n 的字符串。
		?=n	匹配任何其后紧接指定字符串 n 的字符串。
		?!n	匹配任何其后没有紧接指定字符串 n 的字符串。
		
		捕获组可以通过从左到右计算其开括号来编号 。例如，在表达式 (A)(B(C)) 中，存在四个这样的组：
			0   (A)(B(C))
			
			1   (A)
			
			2   (B(C))
			
			3   (C)
		组零始终代表整个表达式
	*/
	var text = "mom and dad and baby";
	var pattern = /mom( and dad( and baby)?)?/gi;   //这里一个括号表示一个"捕获组"
	var matches = pattern.exec(text);//exec()方法返回一个数组(每个元素就是每个捕获组匹配的项) ["mom and dad and baby", " and dad and baby", " and baby"]
	console.log(matches);//
	alert(matches.index); // 0
	alert(matches.input); // "mom and dad and baby"
	alert(matches[0]); // "mom and dad and baby"
	alert(matches[1]); // " and dad and baby"
	alert(matches[2]); // " and baby"
	
	alert(RegExp.$1); //and dad and baby
	alert(RegExp.$2);//and baby
	/*存储捕获组的构造函数属性。访问这些属性的语
法是RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在
调用exec()或test()方法时，这些属性会被自动填充。*/
</script>
<script type="text/javascript">
	/*它会在 RegExpObject 的 lastIndex 属性指定的字符处开始检索字符串 string。当 exec() 找到了与表达式相匹配的文本时，在匹配后，
	它将把 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置*/
	var text = "cat,baidu,ali,tenct";
	var pattern = /t/;
</script>
<script type="text/javascript">
	//字符串模式匹配方法
	//例1
	var text = "cat, bat, sat, fat";
	var pattern = /.at/;
	var matches = text.match(pattern);//该方法与pattern.exec(text)作用是一样的
	alert(matches);//cat
	
	//例2
	var text = "cat, bat, sat, fat";
	var pattern = /.at/g;
	var matches = text.match(pattern);
	alert(matches);//cat,bat,sat,fat
	/*总结：这里exec和match有一些不同，exec方法是属于正则表达式对象的，而match方法是属于字符串的
	 * 再全局匹配下，exec方法也只返回一个结果，再次调用会返回下一个匹配项；而match方法进行了全局匹配搜索，一次性全部返回
	 */
</script>
<!--
	元字符
.	查找单个字符，除了换行和行结束符。
\w	查找单词字符。
\W	查找非单词字符。
\d	查找数字。
\D	查找非数字字符。
\s	查找空白字符。
\S	查找非空白字符。
\b	匹配单词边界。
\B	匹配非单词边界。
\0	查找 NUL 字符。
\n	查找换行符。
\f	查找换页符。
\r	查找回车符。
\t	查找制表符。
\v	查找垂直制表符。
\xxx	查找以八进制数 xxx 规定的字符。
\xdd	查找以十六进制数 dd 规定的字符。
\uxxxx	查找以十六进制数 xxxx 规定的 Unicode 字符。

方括号
方括号用于查找某个范围内的字符：
表达式					描述
[abc]				查找方括号之间的任何字符。
[^abc]				查找任何不在方括号之间的字符。
[0-9]				查找任何从 0 至 9 的数字。
[a-z]				查找任何从小写 a 到小写 z 的字符。
[A-Z]				查找任何从大写 A 到大写 Z 的字符。
[A-z]				查找任何从大写 A 到小写 z 的字符。
[adgk]				查找给定集合内的任何字符。
[^adgk]				查找给定集合外的任何字符。
(red|blue|green)	查找任何指定的选项。

-->
	
